# MIN. REQUIREMENTS
## Introduction
Testing is a crucial aspect of software development that ensures the reliability, functionality, and quality of applications. JUnit and JavaFX testing are two essential frameworks in the Java ecosystem that facilitate the testing of Java applications.

JUnit is a widely adopted testing framework for Java, specifically designed for unit testing. It provides a simple and intuitive way to write and execute test cases, making it an indispensable tool for developers. With JUnit, developers can define test methods that target specific units of code, such as methods or classes, and verify their functionality against expected outcomes.

JavaFX, on the other hand, is a powerful framework for creating rich graphical user interfaces (GUIs) in Java applications. To ensure that the user interface behaves as intended, testing JavaFX applications becomes crucial. JavaFX provides its own testing framework, which includes APIs for automated UI testing, event simulation, and assertion verification.

In this guide, we will explore the capabilities of JUnit and JavaFX testing frameworks, enabling developers to write effective test cases and ensure the robustness of their Java applications. By leveraging these frameworks, developers can gain confidence in the correctness and reliability of their software, leading to better user experiences and increased developer productivity.

## Test Strategy
/*We have implemented functional and non-functional test types so far. Functional test types include unit tests, which are an example of black box testing technique, as they only check for equality of output variables with predefined parameters.*/
JUnit is a framework for unit testing in Java programming. It allows writing and running automated tests, exception testing, and tracking and analyzing test results. By using JUnit, we can ensure that the code is reliable, bug-free, and meets the requirements of our end users.
We use SonarQube as a static code analysis tool to perform security scans to ensure that potential vulnerabilities and threats in the code are identified and fixed as quickly as possible. It also measures code quality against various metrics and standards, allowing code smells to be removed. This makes the code easier to maintain and more secure, thus fulfilling the Security Testing test strategy.
In addition, we have implemented in Maven package that checks all dependencies for known vulnerabilities and security holes. This way we increase the security of our code and follow the testing strategy Security Testing.
We also want to implement the TestFX framework for the GUI, which tests our graphical user interface.
Finally, we pursue the strategy of acceptance testing by having our software operated by human testers. They provide feedback on unusual behavior, errors, the degree of usability (intuitive handling) and suggestions for improvement.

## Test Plan
/*This section outlines the specific testing tasks, timelines, and resources required to achieve the testing objectives.*/
Our JUnit tests currently mainly test the functionalities related to the database. In the future, we also want to test the UI as well as the main methods. 
By implementing Actions in Github, we run two workflows every time we merge with the main branch. One workflow runs the dependency check and another workflow runs our testing. The individual workflows must complete successfully, otherwise the merge is not possible.
The resources we need to achieve the test goals include, for example, csv files that contain data to be written to the database. Also, the testers who will test our software as part of the acceptance testing. The unit tests require the underlying methods and classes that will be tested.

## Test Cases
This section details the specific test cases that were executed, including their pass/fail status and any defects found during testing. (You may link to the repository of your use cases.)

## Test Results
This section summarizes the results of the testing, including major defects found, their severity, and the steps taken to resolve them. (You may link to the test reports generated by your testing tool.)

## Metrics
This section provides quantitative data on the testing process, such as the number of defects found, the defect resolution time, and the test coverage achieved.

## Recommendations
This section offers suggestions for improving the testing process and the quality of the software.

## Conclusion
This section summarizes the key findings of the testing and the overall status of the software quality.
